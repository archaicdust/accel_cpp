

# Input iterator - Sequential read-only access

find(begin, end, x)

  begin++, ++begin (suport ++ both prefix and postfix)
  begin != end, begin == end (==, !=)
  *begin, iter->member, (\*iter).member

# Output iterator - Sequential write-only access

copy(begin, end, dest)

  *dest =
  dest++, ++dest

  write-once requirement

The iterator generated by back_inserter is an output iterator.

# Forward iterator - Sequential read-write access

replace(begin, end, x, y)

  need support the operations supported by an input iterator
  need support the operations supported by an output iterator

  *it (for both reading and writing)
  ++it and it++ (but not --it or it--)
  it == j and it != j (where j has the same type as it)
  it->member (as a synonym for (*it).member)

  single-assign requirement


# Bidirectional iterator - Reversible access

reverse(begin, end)

  meets the requirement of a forward iterator
  --it or it--

# Random access

  the ability to do arithmetic on iterator
  p + n, p - n, and n + p
  p - q
  p\[n] (equivalent to *(p+n))
  p < q, p > q, p <= q, p>=q

sort

The vector and string iterators are random-access iterator.
The list iterator is not; it supports only bidirectional iterators.

list s are optimized for fast insertion and deletion. There is no quick way to
navigate to an arbitrary element of the list. The only way to navigate through a list
is to look at each element in seqence.

